// Copyright (C) 2025 Igor Spichkin

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.

// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

using Content.Shared.UIKit;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;


namespace Content.Client.UIKit.Controls;


[GenerateTypedNameReferences, Virtual,]
public partial class UIKButton : ContainerButton
{
    private readonly bool _isInited;
    private          bool _isDirty;

    public ButtonStyle Style
    {
        get => _style;
        set
        {
            _style   = value;
            _isDirty = true;
        }
    }

    public ButtonBordersStyle BordersStyle
    {
        get => _bordersStyle;
        set
        {
            _bordersStyle = value;
            _isDirty      = true;
        }
    }

    public ButtonColor Color
    {
        get => _color;
        set
        {
            _color   = value;
            _isDirty = true;
        }
    }

    public string? Text { get => ButtonLabel.Text; set => ButtonLabel.Text = value; }

    public string? Icon
    {
        get => _icon;
        set
        {
            _icon    = value;
            _isDirty = true;
        }
    }

    public bool IsIconAtLeft
    {
        get => _isIconAtLeft;
        set
        {
            _isIconAtLeft = value;
            _isDirty      = true;
        }
    }

    public FontType? FontType
    {
        get => _fontType;
        set
        {
            _fontType = value;
            _isDirty  = true;
        }
    }

    public TextStyle? TextStyle
    {
        get => _textStyle;
        set
        {
            _textStyle = value;
            _isDirty   = true;
        }
    }

    public TextStyle? IconTextStyle
    {
        get => _iconTextStyle;
        set
        {
            _iconTextStyle = value;
            _isDirty       = true;
        }
    }

    public FontWeight? FontWeight
    {
        get => _fontWeight;
        set
        {
            _fontWeight = value;
            _isDirty    = true;
        }
    }

    public FontWeight? IconFontWeight
    {
        get => _iconFontWeight;
        set
        {
            _iconFontWeight = value;
            _isDirty        = true;
        }
    }

    public bool? IconFilled
    {
        get => _iconFilled;
        set
        {
            _iconFilled = value;
            _isDirty    = true;
        }
    }

    public Color? FontColor
    {
        get => _fontColor;
        set
        {
            _fontColor = value;
            _isDirty   = true;
        }
    }

    private ButtonStyle        _style = ButtonStyle.Default;
    private ButtonColor        _color = ButtonColor.Default;
    private string?            _icon;
    private TextStyle?         _textStyle;
    private FontWeight?        _fontWeight;
    private FontType?          _fontType;
    private bool?              _iconFilled;
    private FontWeight?        _iconFontWeight;
    private TextStyle?         _iconTextStyle;
    private bool               _isIconAtLeft = true;
    private Color?             _fontColor;
    private ButtonBordersStyle _bordersStyle;

    public UIKButton()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _isDirty  = true;
        _isInited = true;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (!_isDirty)
            return;

        _isDirty = false;
        UpdateAppearance();
    }

    protected override void DrawModeChanged()
    {
        base.DrawModeChanged();

        if (!_isInited)
            return;

        UpdateAppearance();
    }

    private void UpdateAppearance()
    {
        var fontColor = DrawMode == DrawModeEnum.Disabled
            ? Colors.ButtonDisabledLabel
            : FontColor ?? Colors.ButtonLabel;

        ButtonLeftIconLabel.FontColorOverride  = fontColor;
        ButtonRightIconLabel.FontColorOverride = fontColor;
        ButtonLabel.FontColorOverride          = fontColor;

        UIKIcon iconLabel;
        UIKIcon inactiveIconLabel;

        if (IsIconAtLeft)
        {
            iconLabel                             = ButtonLeftIconLabel;
            inactiveIconLabel                     = ButtonRightIconLabel;
            ButtonRightIconLabel.Text             = " ";
            ButtonRightIconLabel.HorizontalExpand = false;
            ButtonRightIconLabel.Visible          = true;
        }
        else
        {
            iconLabel                            = ButtonRightIconLabel;
            inactiveIconLabel                    = ButtonLeftIconLabel;
            ButtonLeftIconLabel.Text             = " ";
            ButtonLeftIconLabel.HorizontalExpand = false;
            ButtonLeftIconLabel.Visible          = true;
        }

        var isIconOnly = string.IsNullOrEmpty(Text);

        if (Icon is { } icon)
        {
            iconLabel.Filled     = IconFilled ?? true;
            iconLabel.TextStyle  = IconTextStyle ?? UIKit.TextStyle.Title2;
            iconLabel.FontWeight = IconFontWeight ?? FontWeight ?? UIKit.FontWeight.Medium;
            iconLabel.Text       = icon;
        }

        if (isIconOnly)
        {
            iconLabel.Visible         = true;
            inactiveIconLabel.Visible = false;
        }

        iconLabel.HorizontalExpand         = isIconOnly;
        ButtonLabel.HorizontalExpand       = !isIconOnly;
        ButtonContainer.SeparationOverride = isIconOnly ? 0 : 8;

        ButtonLabel.FontType   = FontType ?? UIKit.FontType.SansSerif;
        ButtonLabel.FontWeight = FontWeight ?? UIKit.FontWeight.Medium;
        ButtonLabel.TextStyle  = TextStyle ?? UIKit.TextStyle.Body;

        if (Style == ButtonStyle.Ghost)
        {
            ButtonContainer.Margin = new(4.0f, 2.0f);

            StyleBoxOverride = new RectBox
            {
                Rounding = new(0.0f),
                Color    = Robust.Shared.Maths.Color.Transparent
            };

            return;
        }

        ButtonContainer.Margin = new(12.0f, 2.0f);

        Rounding rounding = BordersStyle switch
        {
            ButtonBordersStyle.Rounded   => new(Rounding.Small),
            ButtonBordersStyle.OpenRight => new(Rounding.Small, 0.0f, 0.0f, Rounding.Small),
            ButtonBordersStyle.OpenBoth  => new(0.0f),
            ButtonBordersStyle.OpenLeft  => new(0.0f, Rounding.Small, Rounding.Small, 0.0f),
            ButtonBordersStyle.None      => new(0.0f),
            _                            => throw new ArgumentOutOfRangeException()
        };

        Color   backgroundColor;
        Border? insetBorders;

        if (Style == ButtonStyle.Outlined)
        {
            var insetBorderColor = GetColorFor(Color, DrawModeEnum.Normal);

            backgroundColor = Pressed ? insetBorderColor : Colors.WindowBackground;
            insetBorders = new(
                insetBorderColor,
                new(
                    rounding.TopLeft + rounding.BottomLeft == 0.0f ? 0.0f : 2.0f,
                    2.0f,
                    rounding.TopRight + rounding.BottomRight == 0.0f ? 0.0f : 2.0f,
                    2.0f
                )
            );
        }
        else
        {
            var insetBorderColor = Color switch
            {
                ButtonColor.Default => Colors.ButtonInsetBorder,
                ButtonColor.Accent  => Colors.ButtonAccentInsetBorder,
                ButtonColor.Danger  => Colors.ButtonDangerInsetBorder,
                _                   => throw new ArgumentOutOfRangeException()
            };

            backgroundColor = GetColorFor(Color, DrawMode);
            insetBorders = DrawMode == DrawModeEnum.Disabled
                ? null
                : new(insetBorderColor, new(0.0f, 1.0f, 0.0f, 0.0f));
        }


        StyleBoxOverride = new RectBox
        {
            Rounding = rounding,
            Color    = backgroundColor,
            Inset    = insetBorders ?? new()
        };
    }

    private static Color GetColorFor(ButtonColor buttonColor, DrawModeEnum drawMode) =>
        buttonColor switch
        {
            ButtonColor.Default => drawMode switch
            {
                DrawModeEnum.Disabled => Colors.ButtonDisabledBackground,
                DrawModeEnum.Pressed  => Colors.ButtonPressedBackground,
                _                     => Colors.ButtonBackground
            },
            ButtonColor.Accent => drawMode switch
            {
                DrawModeEnum.Disabled => Colors.ButtonAccentDisabledBackground,
                DrawModeEnum.Pressed  => Colors.ButtonAccentPressedBackground,
                _                     => Colors.ButtonAccentBackground
            },
            ButtonColor.Danger => drawMode switch
            {
                DrawModeEnum.Disabled => Colors.ButtonDangerDisabledBackground,
                DrawModeEnum.Pressed  => Colors.ButtonDangerPressedBackground,
                _                     => Colors.ButtonDangerBackground
            },
            _ => throw new ArgumentOutOfRangeException()
        };
}
